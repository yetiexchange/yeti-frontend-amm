{"ast":null,"code":"import _regeneratorRuntime from\"H:/XETI/YETI-AMM-DEV/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"H:/XETI/YETI-AMM-DEV/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import schema from'@uniswap/token-lists/src/tokenlist.schema.json';import Ajv from'ajv';import contenthashToUri from'./contenthashToUri';import{parseENSAddress}from'./parseENSAddress';import uriToHttp from'./uriToHttp';// bakeryswap defaultTokenJson\nimport{DEFAULT_TOKEN_LIST_URL}from'../constants/lists';import defaultTokenJson from'../constants/token/pancakeswap.json';var tokenListValidator=new Ajv({allErrors:true}).compile(schema);/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */export default function getTokenList(_x,_x2){return _getTokenList.apply(this,arguments);}function _getTokenList(){_getTokenList=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(listUrl,resolveENSContentHash){var parsedENS,urls,_parsedENS$ensPath,contentHashUri,translatedUri,i,url,isLast,response,json,_tokenListValidator$e,_tokenListValidator$e2,validationErrors;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(listUrl===DEFAULT_TOKEN_LIST_URL)){_context.next=2;break;}return _context.abrupt(\"return\",defaultTokenJson);case 2:parsedENS=parseENSAddress(listUrl);if(!parsedENS){_context.next=25;break;}_context.prev=4;_context.next=7;return resolveENSContentHash(parsedENS.ensName);case 7:contentHashUri=_context.sent;_context.next=14;break;case 10:_context.prev=10;_context.t0=_context[\"catch\"](4);console.error(\"Failed to resolve ENS name: \".concat(parsedENS.ensName),_context.t0);throw new Error(\"Failed to resolve ENS name: \".concat(parsedENS.ensName));case 14:_context.prev=14;translatedUri=contenthashToUri(contentHashUri);_context.next=22;break;case 18:_context.prev=18;_context.t1=_context[\"catch\"](14);console.error('Failed to translate contenthash to URI',contentHashUri);throw new Error(\"Failed to translate contenthash to URI: \".concat(contentHashUri));case 22:urls=uriToHttp(\"\".concat(translatedUri).concat((_parsedENS$ensPath=parsedENS.ensPath)!==null&&_parsedENS$ensPath!==void 0?_parsedENS$ensPath:''));_context.next=26;break;case 25:urls=uriToHttp(listUrl);case 26:i=0;case 27:if(!(i<urls.length)){_context.next=57;break;}url=urls[i];isLast=i===urls.length-1;response=void 0;_context.prev=31;_context.next=34;return fetch(url);case 34:response=_context.sent;_context.next=43;break;case 37:_context.prev=37;_context.t2=_context[\"catch\"](31);console.error('Failed to fetch list',listUrl,_context.t2);if(!isLast){_context.next=42;break;}throw new Error(\"Failed to download list \".concat(listUrl));case 42:return _context.abrupt(\"continue\",54);case 43:if(response.ok){_context.next=47;break;}if(!isLast){_context.next=46;break;}throw new Error(\"Failed to download list \".concat(listUrl));case 46:return _context.abrupt(\"continue\",54);case 47:_context.next=49;return response.json();case 49:json=_context.sent;if(tokenListValidator(json)){_context.next=53;break;}validationErrors=(_tokenListValidator$e=(_tokenListValidator$e2=tokenListValidator.errors)===null||_tokenListValidator$e2===void 0?void 0:_tokenListValidator$e2.reduce(function(memo,error){var _error$message;var add=\"\".concat(error.dataPath,\" \").concat((_error$message=error.message)!==null&&_error$message!==void 0?_error$message:'');return memo.length>0?\"\".concat(memo,\"; \").concat(add):\"\".concat(add);},''))!==null&&_tokenListValidator$e!==void 0?_tokenListValidator$e:'unknown error';throw new Error(\"Token list failed validation: \".concat(validationErrors));case 53:return _context.abrupt(\"return\",json);case 54:i++;_context.next=27;break;case 57:throw new Error('Unrecognized list URL protocol.');case 58:case\"end\":return _context.stop();}}},_callee,null,[[4,10],[14,18],[31,37]]);}));return _getTokenList.apply(this,arguments);}","map":{"version":3,"sources":["H:/XETI/YETI-AMM-DEV/src/utils/getTokenList.ts"],"names":["schema","Ajv","contenthashToUri","parseENSAddress","uriToHttp","DEFAULT_TOKEN_LIST_URL","defaultTokenJson","tokenListValidator","allErrors","compile","getTokenList","listUrl","resolveENSContentHash","parsedENS","ensName","contentHashUri","console","error","Error","translatedUri","urls","ensPath","i","length","url","isLast","response","fetch","ok","json","validationErrors","errors","reduce","memo","add","dataPath","message"],"mappings":"mRACA,MAAOA,CAAAA,MAAP,KAAmB,gDAAnB,CACA,MAAOC,CAAAA,GAAP,KAAgB,KAAhB,CACA,MAAOC,CAAAA,gBAAP,KAA6B,oBAA7B,CACA,OAASC,eAAT,KAAgC,mBAAhC,CACA,MAAOC,CAAAA,SAAP,KAAsB,aAAtB,CAEA;AACA,OAASC,sBAAT,KAAuC,oBAAvC,CACA,MAAOC,CAAAA,gBAAP,KAA6B,qCAA7B,CAEA,GAAMC,CAAAA,kBAAkB,CAAG,GAAIN,CAAAA,GAAJ,CAAQ,CAAEO,SAAS,CAAE,IAAb,CAAR,EAA6BC,OAA7B,CAAqCT,MAArC,CAA3B,CAEA;AACA;AACA;AACA;AACA,GACA,uBAA8BU,CAAAA,YAA9B,qD,+FAAe,iBACbC,OADa,CAEbC,qBAFa,mRAITD,OAAO,GAAKN,sBAJH,0DAKJC,gBALI,SAOPO,SAPO,CAOKV,eAAe,CAACQ,OAAD,CAPpB,KAUTE,SAVS,gEAacD,CAAAA,qBAAqB,CAACC,SAAS,CAACC,OAAX,CAbnC,QAaTC,cAbS,gGAeTC,OAAO,CAACC,KAAR,uCAA6CJ,SAAS,CAACC,OAAvD,eAfS,KAgBH,IAAII,CAAAA,KAAJ,uCAAyCL,SAAS,CAACC,OAAnD,EAhBG,0BAoBTK,aAAa,CAAGjB,gBAAgB,CAACa,cAAD,CAAhC,CApBS,kFAsBTC,OAAO,CAACC,KAAR,CAAc,wCAAd,CAAwDF,cAAxD,EAtBS,KAuBH,IAAIG,CAAAA,KAAJ,mDAAqDH,cAArD,EAvBG,SAyBXK,IAAI,CAAGhB,SAAS,WAAIe,aAAJ,6BAAoBN,SAAS,CAACQ,OAA9B,yDAAyC,EAAzC,EAAhB,CAzBW,+BA2BXD,IAAI,CAAGhB,SAAS,CAACO,OAAD,CAAhB,CA3BW,QA6BJW,CA7BI,CA6BA,CA7BA,cA6BGA,CAAC,CAAGF,IAAI,CAACG,MA7BZ,2BA8BLC,GA9BK,CA8BCJ,IAAI,CAACE,CAAD,CA9BL,CA+BLG,MA/BK,CA+BIH,CAAC,GAAKF,IAAI,CAACG,MAAL,CAAc,CA/BxB,CAgCPG,QAhCO,gDAkCQC,CAAAA,KAAK,CAACH,GAAD,CAlCb,SAkCTE,QAlCS,iGAoCTV,OAAO,CAACC,KAAR,CAAc,sBAAd,CAAsCN,OAAtC,cApCS,IAqCLc,MArCK,+BAqCS,IAAIP,CAAAA,KAAJ,mCAAqCP,OAArC,EArCT,0DA0CNe,QAAQ,CAACE,EA1CH,8BA2CLH,MA3CK,+BA2CS,IAAIP,CAAAA,KAAJ,mCAAqCP,OAArC,EA3CT,8EAgDQe,CAAAA,QAAQ,CAACG,IAAT,EAhDR,SAgDLA,IAhDK,kBAiDNtB,kBAAkB,CAACsB,IAAD,CAjDZ,0BAkDHC,gBAlDG,gDAmDPvB,kBAAkB,CAACwB,MAnDZ,iDAmDP,uBAA2BC,MAA3B,CAA0C,SAACC,IAAD,CAAOhB,KAAP,CAAiB,oBACzD,GAAMiB,CAAAA,GAAG,WAAMjB,KAAK,CAACkB,QAAZ,6BAAwBlB,KAAK,CAACmB,OAA9B,iDAAyC,EAAzC,CAAT,CACA,MAAOH,CAAAA,IAAI,CAACV,MAAL,CAAc,CAAd,WAAqBU,IAArB,cAA8BC,GAA9B,YAAyCA,GAAzC,CAAP,CACD,CAHD,CAGG,EAHH,CAnDO,+DAsDG,eAtDH,MAuDH,IAAIhB,CAAAA,KAAJ,yCAA2CY,gBAA3C,EAvDG,yCAyDJD,IAzDI,UA6BoBP,CAAC,EA7BrB,qCA2DP,IAAIJ,CAAAA,KAAJ,CAAU,iCAAV,CA3DO,sF","sourcesContent":["import { TokenList } from '@uniswap/token-lists'\nimport schema from '@uniswap/token-lists/src/tokenlist.schema.json'\nimport Ajv from 'ajv'\nimport contenthashToUri from './contenthashToUri'\nimport { parseENSAddress } from './parseENSAddress'\nimport uriToHttp from './uriToHttp'\n\n// bakeryswap defaultTokenJson\nimport { DEFAULT_TOKEN_LIST_URL } from '../constants/lists'\nimport defaultTokenJson from '../constants/token/pancakeswap.json'\n\nconst tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\n\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\nexport default async function getTokenList(\n  listUrl: string,\n  resolveENSContentHash: (ensName: string) => Promise<string>\n): Promise<TokenList> {\n  if (listUrl === DEFAULT_TOKEN_LIST_URL) {\n    return defaultTokenJson\n  }\n  const parsedENS = parseENSAddress(listUrl)\n\n  let urls: string[]\n  if (parsedENS) {\n    let contentHashUri\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName)\n    } catch (error) {\n      console.error(`Failed to resolve ENS name: ${parsedENS.ensName}`, error)\n      throw new Error(`Failed to resolve ENS name: ${parsedENS.ensName}`)\n    }\n    let translatedUri\n    try {\n      translatedUri = contenthashToUri(contentHashUri)\n    } catch (error) {\n      console.error('Failed to translate contenthash to URI', contentHashUri)\n      throw new Error(`Failed to translate contenthash to URI: ${contentHashUri}`)\n    }\n    urls = uriToHttp(`${translatedUri}${parsedENS.ensPath ?? ''}`)\n  } else {\n    urls = uriToHttp(listUrl)\n  }\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const isLast = i === urls.length - 1\n    let response\n    try {\n      response = await fetch(url)\n    } catch (error) {\n      console.error('Failed to fetch list', listUrl, error)\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const json = await response.json()\n    if (!tokenListValidator(json)) {\n      const validationErrors: string =\n        tokenListValidator.errors?.reduce<string>((memo, error) => {\n          const add = `${error.dataPath} ${error.message ?? ''}`\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n        }, '') ?? 'unknown error'\n      throw new Error(`Token list failed validation: ${validationErrors}`)\n    }\n    return json\n  }\n  throw new Error('Unrecognized list URL protocol.')\n}\n"]},"metadata":{},"sourceType":"module"}